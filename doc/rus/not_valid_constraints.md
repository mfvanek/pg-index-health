# Проверка наличия ограничений, которые не были провалидированы

## Почему данные могут не соответствовать существующим ограничениям

- [Источник](https://habr.com/ru/articles/800121/)

Некоторые типы ограничений (в настоящее время это ограничение-проверка `CHECK` и, с некоторыми оговорками, `FOREIGN KEY`),
могут создаваться с ключом `NOT VALID`.
При создании ограничений для больших таблиц проверка уже имеющихся данных может быть длительной,
поэтому разработчики пользуются удобным механизмом в PostgreSQL и разделяют процессы создания ограничения и проверки всех данных.

Важно отметить, что ограничение сразу после создания будет действовать при добавлении или изменении данных,
и любая из этих операций будет прервана, если новые данные не соответствуют ограничению.
Однако на уровне базы данных будет установлен признак, что ограничение не было проверено для всех данных,
пока оно не будет проверено командой `VALIDATE CONSTRAINT`.

## SQL запрос

- [not_valid_constraints.sql](https://github.com/mfvanek/pg-index-health-sql/blob/master/sql/not_valid_constraints.sql)

## Тип проверки

- **runtime** (имеет смысл запускать на работающем инстансе БД после выполнения миграций)
- **static** (может выполняться в компонентных\интеграционных тестах для проверки корректности миграций)

## Поддержка секционированных таблиц

Поддерживает секционированные таблицы.
Проверка выполняется на самой секционированной таблице (родительской). Отдельные секции (потомки) игнорируются.
